#-------------------------------------------------------------------------------
# Name:        drone_bb_test.py
# Purpose:
#
# Author:      Mattia Gramuglia
#
# Created:     4/25/2023       
#-------------------------------------------------------------------------------

def main():
    pass

if __name__ == '__main__':
    main()

import os
import math
import time
import datetime
import sys, getopt
import pytz
import csv
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as irr

import numpy as np
from numpy import linalg as LA
import scipy
from scipy import linalg
from scipy.sparse.linalg import eigsh

import acsl_pychrono.user_defined_trajectory as Traj
import acsl_pychrono.control as Ctrl
import acsl_pychrono.simulation.simulation as sim
import acsl_pychrono.functions as fun
from acsl_pychrono.control.logging import Logging
from acsl_pychrono.ode_input import OdeInput
from acsl_pychrono.flight_params import FlightParams

# ---------------------------------------------------------------------
#%%The main wrapper function starts!-------------------------------------------------------------------------------------------------------
def WrapperMain_function(target_folder, controller_type, wrapper_control_parameters, wrapper_foldername, wrapper_filename, max_simulation_time, csv_file_path_abnormalities, Wrapper_execution, visualization_flag):
    print("Wrapper loop starts here")
    global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot
    global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
    global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
    global mu_PD_baseline_tran, Moment_baseline_PI, e_tran, integral_eQe_tran, e_rot, integral_eQe_rot
    global epsilon_tran, integral_epsQeps_tran, epsilon_rot, integral_epsQeps_rot, e_transient_tran
    global integral_etQet_tran, e_transient_rot, integral_etQet_rot, omega_ref_dot, omega_cmd, omega_cmd_dot
    global Jacobian_matrix, Jacobian_matrix_dot, angular_error

    #%% File settings
    
    # Parse command-line parameters
    m_filename = "drone_bb.py"
    m_timestep = 0.005 #0.005 - 0.01
    m_length = 1.0
    m_visualization = "irrlicht"
    # m_datapath = "C:/workspace/chrono/data/"  # change this accordingly to where you saved chrono data
    m_datapath = "C:/ProgramData/Anaconda/envs/chrono/Library/data/"  # change this accordingly to where you saved chrono data
    
    # m_filename_env = os.getcwd() + "/assets/environments/environment3.py"
    m_filename_env = os.getcwd() + "/assets/environments/environmentA.py"

    #%% Importing bodies and constraints from the solidworks generated file
    # ----------------------------------------------------------------
    #                     INCLUDE ENVIRONMENT
    # ----------------------------------------------------------------
    # environment_included = True
    environment_included = False
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    #  load the file generated by the SolidWorks CAD plugin
    #  and add it to the ChSystem.
    # Remove the trailing .py and add / in case of file without ./
    m_absfilename = os.path.abspath(m_filename)
    m_modulename = os.path.splitext(m_absfilename)[0]
    
    exported_items = chrono.ImportSolidWorksSystem(m_modulename)
    
    # Print exported items
    for my_item in exported_items:
    	print (my_item.GetName())
    # Add items to the physical system
    my_system = chrono.ChSystemNSC()
    for my_item in exported_items:
    	my_system.Add(my_item)

    if environment_included == True:
    
        # Remove the trailing .py and add / in case of file without ./
        m_absfilename_env = os.path.abspath(m_filename_env)
        m_modulename_env = os.path.splitext(m_absfilename_env)[0]
        exported_items_env = chrono.ImportSolidWorksSystem(m_modulename_env)
        
        # Print exported items
        for my_item_env in exported_items_env:
        	print (my_item_env.GetName())
         # Add items to the physical system
        	my_system.Add(my_item_env)
        
        # Assigning names to the bodies imported from solidworks and checking if they are found
        my_environment = my_system.SearchBody('environment1-1')
        my_environment = my_system.SearchBody('environmentA-1')
        if my_environment :
            print('Environment found!')
        if not my_environment :
            sys.exit('Error: cannot find Environment from its name in the C::E system!')
            
   #%% Defining Wrapper control parameters and creating folders and files            
    if Wrapper_execution == True:		
        folder_path = os.path.join(target_folder, wrapper_foldername)
    
        # Create the folder if it doesn't exist
        if not os.path.exists(folder_path):
            os.mkdir(folder_path)
            print(f"Folder '{wrapper_foldername}' created successfully.")
        
        wrapper_filename_csv = wrapper_filename  + ".csv"
        csv_file_path = os.path.join(folder_path, wrapper_filename_csv)
        
    #Wrapper parameters passed-------------------------------------
    my_ball_density = wrapper_control_parameters["my_ball_density"]
    		
    #%% Solver parameters
    #my_system.SetMaxPenetrationRecoverySpeed(1.00)
    # my_solver = chrono.ChSolverBB() # default solver set by the solidworks pychrono module
    my_solver = chrono.ChSolverPSOR() # same solver as 'demo_MBS_collisionNSC'
    my_system.SetSolver(my_solver)
    my_solver.SetMaxIterations(1000) #600 #1000
    my_solver.EnableWarmStart(True)
    
    chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.001) #0.003 #0.001
    chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.0005) #0.003 #0.0005
    chrono.ChCollisionSystemBullet.SetContactBreakingThreshold(0.001) #0.002 #0.001

    # Instantiation of classes
    flight_params = FlightParams()
    ode_input = OdeInput()

    #%% System and General parameters
    my_system.Set_G_acc(chrono.ChVectorD(0,-flight_params.G_acc,0))
    # my_system.Set_G_acc(chrono.ChVectorD(0,0,0)) # No Gravity
    position_local_pixhawk = chrono.ChVectorD(0.0293, 0.04925, 0) # position of the "pixhawk's center" wrt local frame
    position_pixhawk_fromCOG = chrono.ChVectorD(-0.0214807964657055, 0.0779592340719906, -0.0000487571767365452) # position of the "pixhawk's center" wrt the COG of the drone frame
    global_coord = chrono.ChCoordsysD(chrono.ChVectorD(0,0,0), chrono.ChQuaternionD(1,0,0,0)) # Global reference frame
    pixhawk_csys = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)) # Coordinate System Pixhawk
    
    pixhawk_csys_fixed = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0))# Coordinate System as Pixhawk convention but fixed to ground
    
    force_1_5_pos = chrono.ChVectorD(-0.08760601358, -0.0085, -0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 1 & 5
    force_2_6_pos = chrono.ChVectorD(0.08812691616, -0.0085, -0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 2 & 6
    force_3_7_pos = chrono.ChVectorD(0.08760601358, -0.0085, 0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 3 & 7
    force_4_8_pos = chrono.ChVectorD(-0.08812691616, -0.0085, 0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 4 & 8
    
    #%% Assigning names to the bodies imported from solidworks and checking if they are found
    (my_ground, my_frame, my_box,
     my_prop1, my_prop2, my_prop3, my_prop4,
     my_prop5, my_prop6, my_prop7, my_prop8) = sim.loadBodies(my_system)
        
    # Assigning names to the Coordinate Systems/Markers imported from solidworks and checking if they are found
    (my_marker1, my_marker2, my_marker3, my_marker4,
     my_marker5, my_marker6, my_marker7, my_marker8) = sim.loadMarkers(my_system)

    #%% Create bodies and floor
    
    # Create contact materials and set their properties
    contact_material_floor = chrono.ChMaterialSurfaceNSC()
    contact_material_floor.SetFriction(1) # 1
    contact_material_floor.SetDampingF(0.5) # 0.5
    contact_material_ball = chrono.ChMaterialSurfaceNSC()    
     
    # Create a floor
    mfloor = chrono.ChBodyEasyBox(50, 0.1, 50, 1000,True,True, contact_material_floor)
    mfloor.SetName('Floor')
    mfloor.SetBodyFixed(True)
    mfloor_Yposition = 0.3
    mfloor.SetPos(chrono.ChVectorD(0,-mfloor_Yposition,0))
    # mfloor.SetPos(chrono.ChVectorD(0,-0.5,0))
    mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/light_gray.png"))
    # mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/concrete.jpg"))
    # mfloor.GetVisualShape(0).SetColor(chrono.ChColor(1, 1, 1))
    my_system.Add(mfloor)
    
    my_ball1 = chrono.ChBodyEasySphere(0.0254,      # radius size # 0.0254 - 0.01905 - 0.015875
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball1.SetName('Ball_1')
    my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0.065)) # -0.05,-0.15,0
    # my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0))
    my_ball1.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
    # my_ball1.GetVisualShape(0).SetColor(chrono.ChColor(0, 1, 0))
    my_system.Add(my_ball1)
    
    my_ball2 = chrono.ChBodyEasySphere(0.0254,      # radius size
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball2.SetName('Ball_2')
    my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0.065))
    # my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0))
    my_ball2.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker2.png"))
    # my_ball2.GetVisualShape(0).SetColor(chrono.ChColor(0, 0, 1))
    my_system.Add(my_ball2)
    # my_ball2.SetWvel_loc(chrono.ChVectorD(0,0,5))
    # my_ball2.SetPos_dt(chrono.ChVectorD(0,1,0))
    
    #%% Additional bodies
    # for bi in range(20):
    #     my_ball3 = chrono.ChBodyEasySphere(0.015875,      # radius size
    #                                           7850,     # density 7850
    #                                           True,     # visualization?
    #                                           True,     # collision?
    #                                           contact_material_ball)  # contact material
    #     my_ball3.SetName('Ball_3')
    #     my_ball3.SetPos(chrono.ChVectorD(-0.05 + chrono.ChRandom() * 0.1,-0.2 + chrono.ChRandom() * 0.05, -0.05 + chrono.ChRandom() * 0.1))
    #     my_ball3.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker1.png"))
    #     my_system.Add(my_ball3)

    #========================================================================================================================================
    # # Adding multiple balls    
    # def create_and_add_sphere_body(index, system, radius, density, visualize=True, collision=True, contact_material=None):
    #     sphere_body = chrono.ChBodyEasySphere(radius, density, visualize, collision, contact_material)
    #     sphere_body.SetName('Ball_3_{}'.format(index))  # Add a random number to the name
    #     sphere_body.SetPos(chrono.ChVectorD(
    #         # -0.05 + chrono.ChRandom() * 0.1,
    #         # -0.2 + chrono.ChRandom() * 0.05,
    #         # -0.05 + chrono.ChRandom() * 0.1
    #         -0.05 + 0.035 * index * (index<5) + 0.035 * (index-5) * (index>=5),
    #         -0.2,
    #         -0.05+ 0.1 * (index>=5)
    #     ))
    #     sphere_body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
    #     system.Add(sphere_body)  # Add the sphere body to the provided system
    #     return sphere_body
    
    # # my_ball3_1 = create_and_add_sphere_body(1, my_system, 0.015875, 7850, True, True, contact_material_ball)
    # # my_ball3_2 = create_and_add_sphere_body(2, my_system, 0.015875, 7850, True, True, contact_material_ball)
    
    # for i in range(0, 10):
    #     variable_name = f'my_ball3_{i}'  # Construct the variable name
    #     globals()[variable_name] = create_and_add_sphere_body(i, my_system, 0.015875, my_ball_density, True, True, contact_material_ball)
    #========================================================================================================================================
        
    # print('Ball 3 mass in kg: ',my_ball3.GetMass())
    
    # my_ball4 = chrono.ChBodyEasySphere(0.015875,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball4.SetName('Ball_4')
    # my_ball4.SetPos(force_4_8_pos)
    # my_ball4.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # my_system.Add(my_ball4)
    
    # my_ball4.SetBodyFixed(True)
    
    # my_ball4 = chrono.ChBodyEasySphere(0.02,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball4.SetName('Ball_4')
    # # my_ball4.SetPos(chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05)) # my_COG_local
    # my_ball4.SetPos(chrono.ChVectorD(0.0063298425197185135, -0.057308727962443, -3.9465411906584656e-05)) # COG
    # # my_ball4.SetPos(chrono.ChVectorD(0,0,0))
    # my_ball4.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # my_system.Add(my_ball4)
    
    # my_ball4.SetBodyFixed(True)
    
    # my_ball5 = chrono.ChBodyEasySphere(0.0254,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball5.SetName('Ball_5')
    # my_ball5.SetPos(chrono.ChVectorD(-0.75,-0.1,0))
    # my_ball5.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/pink.png"))
    # my_system.Add(my_ball5)
    # # print('Ball 1 mass in kg: ',my_ball1.GetMass())
    
    # my_ball6 = chrono.ChBodyEasySphere(0.0254,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball6.SetName('Ball_6')
    # my_ball6.SetPos(position_local_pixhawk)
    # my_ball6.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # # my_ball6.SetBodyFixed(True)
    # my_system.Add(my_ball6)
    
    # body_A= chrono.ChBodyEasyBox(1, 1, 1, 1000,True,True, contact_material_ball)                              
    # body_A.SetPos(chrono.ChVectorD(0,1,0))
    # # body_A.SetRot(chrono.ChQuaternionD(0.3827,0.9239,0,0))
    # body_A.SetRot(chrono.ChQuaternionD(0.2588,0.9659,0,0))
    # body_A.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/pink.png"))
    # my_system.Add(body_A)
    
    # my_frame.SetBodyFixed(True)

    #%% Create additional reference systems (ChMarkers) 
    
    # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    marker_pixhawk =chrono.ChMarker()
    marker_pixhawk.SetName('Coordinate System Pixhawk')
    my_frame.AddMarker(marker_pixhawk)
    marker_pixhawk.Impose_Abs_Coord(pixhawk_csys)
    
    # Create a local reference system with origin in pixhawk and with Global Frame convention (Y up)
    pixhawk_csys_2 = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(1,0,0,0)) # Coordinate System Pixhawk
    marker_pixhawk_2 =chrono.ChMarker()
    marker_pixhawk_2.SetName('Coordinate System Pixhawk Global Frame convention')
    my_frame.AddMarker(marker_pixhawk_2)
    marker_pixhawk_2.Impose_Abs_Coord(pixhawk_csys_2)
    
    # my_frame.SetWvel_loc(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    # my_frame.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    # my_ball3.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    
    # # Rotation matrix that represents a rotation of minus pi/2 (-90 degrees) around the x-axis
    # RR = chrono.ChMatrix33D()
    # RRX_minusPI2 = [[1,0,0],
    #                 [0,0,-1],
    #                 [0,1,0]]
    # RR.SetMatr(RRX_minusPI2)
    
    # Rotation matrix that represents a rotation of plus pi/2 (90 degrees) around the x-axis
    RR = chrono.ChMatrix33D()
    RRX_plusPI2 = [[ 1, 0, 0],
                    [0, 0, 1],
                    [0,-1, 0]]
    RR.SetMatr(RRX_plusPI2)
    
    # QQ = chrono.ChQuaternionD(0.70710678118,-0.70710678118,0,0) # Rotation around x of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,-0.70710678118,0) # Rotation around y of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,-0.70710678118) # Rotation around z of -pi/2
    
    # QQ = chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0) # Rotation around x of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0.70710678118,0) # Rotation around y of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,0.70710678118) # Rotation around z of pi/2
    
    # QQ = chrono.ChQuaternionD(0.96592582628,0.2588190451,0,0) # Rotation around x of 30 degrees
    
    # marker_pixhawk.SetRot(RR)
    # marker_pixhawk.SetRot(QQ)
    # my_frame.SetRot(RR)
    # my_frame.SetRot(QQ)
    
    # # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    # marker_ball3 =chrono.ChMarker()
    # marker_ball3.SetName('Coordinate System Ball 3')
    # my_ball3.AddMarker(marker_ball3)
    # marker_ball3.Impose_Abs_Coord(chrono.ChCoordsysD(chrono.ChVectorD(0,1,0),chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)))
    
    # Identify Local reference system of Box
    my_box_csys = my_box.GetFrame_REF_to_abs().GetCoord()
    # Identify Local reference system of Ball_1
    my_ball1_csys = my_ball1.GetFrame_REF_to_abs().GetCoord()
    # Identify Local reference system of Ball_2
    my_ball2_csys = my_ball2.GetFrame_REF_to_abs().GetCoord()
    # Identify Local reference system of drone frame
    my_frame_csys = my_frame.GetFrame_REF_to_abs().GetCoord()

    #%% Making the Propellers spin  
    props = (my_prop1, my_prop2, my_prop3, my_prop4,
             my_prop5, my_prop6, my_prop7, my_prop8)

    markers = (my_marker1, my_marker2, my_marker3, my_marker4,
               my_marker5, my_marker6, my_marker7, my_marker8)
    
    motors = sim.addMotors(my_system, my_frame, props, markers)

    (link_motor1, link_motor2, link_motor3, link_motor4,
     link_motor5, link_motor6, link_motor7, link_motor8) = motors

    #%% Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
    # Get the mass of each body
    my_frame_mass = my_frame.GetMass()
    my_box_mass = my_box.GetMass()
    my_prop_mass = my_prop1.GetMass() # same for each propeller
    my_ball1_mass = my_ball1.GetMass()
    my_ball2_mass = my_ball2.GetMass()
    
    mass_total = my_frame_mass + my_box_mass + 8*(my_prop_mass)
    mass_total_wballs = my_frame_mass + my_box_mass + 8*(my_prop_mass) + my_ball1_mass + my_ball2_mass
    
    COG_total = chrono.ChVectorD()
    COG = chrono.ChVectorD()

    #%% Forces and Torques
    my_frame.Accumulate_force(chrono.ChVectorD(0,0,0),chrono.VNULL,True)
    
    # ----------------------------------------------------------------
    #!!!                     CHOOSE THE TRAJECTORY
    # ----------------------------------------------------------------
    
    # trajectory_type = 'circular_trajectory'
    
    # trajectory_type = 'hover_trajectory'
    
    # trajectory_type = 'square_trajectory'
    
    # trajectory_type = 'rounded_rectangle_trajectory'
    
    trajectory_type = 'piecewise_polynomial_trajectory'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------

    trajectory_classes = {
        'circular_trajectory': Traj.CircularTrajectory,
        'hover_trajectory': Traj.HoverTrajectory,
        'square_trajectory': Traj.SquareTrajectory,
        'rounded_rectangle_trajectory': Traj.RoundedRectangleTrajectory,
        'piecewise_polynomial_trajectory': Traj.PiecewisePolynomialTrajectory,
    }

    TrajectoryClass = trajectory_classes.get(trajectory_type)

    if TrajectoryClass is not None:
        user_defined_trajectory = TrajectoryClass(flight_params, mfloor, mfloor_Yposition)
    else:
        raise ValueError(f"Unknown trajectory type: {trajectory_type}")
    
    # ----------------------------------------------------------------
    #                     CONTROLLERS
    # ----------------------------------------------------------------
    
    # controller_type = 'PID'
    
    # controller_type = 'MRAC'
    
    # controller_type = 'TwoLayerMRACwithBASELINE'
    
    # controller_type = 'RobustMRACwithBASELINE'
    
    #controller_type = 'RobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridMRACwithBASELINE'
    
    # controller_type = 'HybridTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridRobustMRACwithBASELINE'
    
    # controller_type = 'HybridRobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'FunnelMRACwithBASELINE'
    
    # controller_type = 'FunnelTwoLayerMRACwithBASELINE'
    
    # controller_type = 'FunnelMRACnew'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------

    controller_classes = {
        'PID': (Ctrl.PIDGains, Ctrl.PID, Ctrl.PIDLogger),
        'MRAC': (Ctrl.MRACGains, Ctrl.MRAC, Ctrl.MRACLogger),
        # Add other controller types here as needed
    }

    if controller_type in controller_classes:
        GainsClass, ControllerClass, LoggerClass = controller_classes[controller_type]
        # Instantiation
        gains = GainsClass(flight_params)
        controller = ControllerClass(gains, ode_input, flight_params)
        logger = LoggerClass(gains)
    else:
        raise ValueError(f"Unknown controller type: {controller_type}")   

    #%% Control Algorithms ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    # Initial conditions
    y0 = np.zeros((gains.number_of_states,1))
    Y = np.zeros((gains.number_of_states,1))
    Y_list = Y
    Y[:, 0] = np.ravel(y0)
    yin = y0
    dy = np.zeros((gains.number_of_states,1))
    y = np.zeros((gains.number_of_states,1))

    if controller_type == "FunnelMRACnew":
        yin[100] = math.sqrt(gains.eta_max_funnel_tran - 0.5)  # Initial condition on funnel translational
    
    # ------------------------------------------------------------------------------------------------------------------
    my_frame_pos_GLOB = my_frame.GetPos()

    #%% Irrlicht visualization
    if visualization_flag == True:    
        #******************************************************************************    
        # Create the Irrlicht visualization
        vis = irr.ChVisualSystemIrrlicht()
        vis.AttachSystem(my_system)
        # vis.SetWindowSize(1024,768)
        vis.SetWindowSize(1280,960)
        # vis.SetWindowSize(1536,1152)
        vis.SetWindowTitle('X8-Copter - Controller: ' + controller_type)
        vis.Initialize()
        vis.AddLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
        vis.AddSkyBox()
        # vis.AddCamera(chrono.ChVectorD(2.5, 1.5, 0.5)) #(1,1,1) - (2.5,1.5,0.5) FIXED CAMERA
        vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
        # vis.AddCamera(chrono.ChVectorD(6,1.5,3), chrono.ChVectorD(3,0,-2))
        # vis.AddCamera(chrono.ChVectorD(2, 1, 3), chrono.ChVectorD(2,0.5,1.5))
        vis.AddTypicalLights()
        # vis.AddLightWithShadow(chrono.ChVectorD(3,6,2),    # point
        #                               chrono.ChVectorD(0,0,0),    # aimpoint
        #                               12,                 # radius (power)
        #                               1,11,              # near, far
        #                               55)                # angle of FOV
        vis.AddLightWithShadow(chrono.ChVectorD(0,5,0),    # point
                                      chrono.ChVectorD(3,2,0),    # aimpoint
                                      5,                 # radius (power)
                                      1,8,              # near, far
                                      55)                # angle of FOV
        vis.BindAll()
    #******************************************************************************     
    my_frame_pos_GLOB = my_frame.GetPos() # Do this if you want to print the position value of the drone frame to monitor
    my_frame_quat = my_frame.GetRot()
    my_ball1_pos = my_ball1.GetPos()
    my_ball2_pos = my_ball2.GetPos()
    
    DATA = []
    #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    date = datetime.datetime.now()
    start_simulation_time = time.time() # Time acquired in order to measure the execution time of the simulation
    
    # Simulation loop
    while my_system.GetChTime()<max_simulation_time:
    #****************************************************************************** 
   # while vis.Run():
        if visualization_flag == True:
            vis.BeginScene()            
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(2, 0.2, 1), my_frame_pos_GLOB)
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(2, 2, -1), my_frame_pos_GLOB)
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            # if my_system.GetChTime() < 6:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            # if my_system.GetChTime() >= 6 and my_system.GetChTime() < 7:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(1.5, 2, -1.5), my_frame_pos_GLOB)
            # Camera fixed with drone orientation
            # if my_system.GetChTime() > 0.1:
            #     # vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.55, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0))
            #     vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.4, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0))
            vis.Render()
            irr.drawCoordsys(vis, marker_pixhawk.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (NED) during the simulation
            # irr.drawCoordsys(vis, marker_pixhawk_2.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (Y up) during the simulation
            # irr.drawCoordsys(vis, pixhawk_csys_fixed, 4) # Draw the fixed coordinate system of pixhawk during the simulation
            # irr.drawCoordsys(vis, marker_ball3.GetAbsCoord(), 0.5) # Draw the coordinate system of ball3 during the simulation
            irr.drawCoordsys(vis, global_coord, 1) # Draw the Global coordinate system during the simulation
            # irr.drawCoordsys(vis, my_ball1_csys, 0.3) #Draw the csys of ball1
            # irr.drawCoordsys(vis, my_prop1.GetCoord(), 0.3) #Draw the csys of propeller 1
            # irr.drawCoordsys(vis, my_ball2_csys, 0.3) #Draw the csys of ball2
            # irr.drawAllCOGs(vis,0.05) # Draw the Center Of Gravity of all bodies
            vis.EndScene()
        #******************************************************************************    
        
            if not vis.Run():
                break
        my_system.DoStepDynamics(m_timestep)
        
        my_frame.Empty_forces_accumulators() # Command that MUST be used in conjunction with Accumulate_force() and Accumulate_torque() used below
        
        ##################################################################################################################################################################################
             
        ################ Build lists to export data ################
        time_now = my_system.GetChTime() # Time "inside" the simulation
        
        simulation_time = time.time() - start_simulation_time # Time that the simulation is taking
        
        # Global coordinates of the origin of the drone frame containing just the position
        my_frame_pos_GLOB = my_frame.GetPos() 
    
        # GLOBAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        coord_pixhawk_GLOB = marker_pixhawk.GetAbsCoord() # Global coordinates of the pixhawk containing both its position and rotation (quaternion)
        coord_dt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dt() # Global velocities of the pixhawk derived from its position and rotation (quaternion)
        coord_dtdt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dtdt() # Global accelerations of the pixhawk derived from its position and rotation (quaternion)
        Wvel_pixhawk_GLOB = marker_pixhawk.GetAbsWvel() # Angular velocity of the pixhawk respect to global coordinates, expressed in global coordinates
        Wacc_pixhawk_GLOB = marker_pixhawk.GetAbsWacc() # Angular acceleration of the pixhawk respect to global coordinates, expressed in global coordinates
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # LOCAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        pixhawk_rotmat = chrono.ChMatrix33D(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        pixhawk_rotmat_F = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk to go from Global to Local coordinates (computed using Mattia's function: fun.rotmat_fromQ_Glob_to_Loc_asarray)
        
        # pixhawk_rotmat_T_array = np.transpose(np.asarray(pixhawk_rotmat.GetMatr())) # TRANSPOSED rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        # pixhawk_rotmat_T = chrono.ChMatrix33D()
        # pixhawk_rotmat_T.SetMatr(pixhawk_rotmat_T_array)
        
        # pixhawk_csys_fixed_rotmat_array = fun.rotmat_fromQ_Glob_to_Loc_asarray(pixhawk_csys_fixed.rot)
        # pixhawk_csys_fixed_rotmat = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(pixhawk_csys_fixed.rot)
        # pixhawk_csys_fixed_rotmat_array_transposed = np.transpose(pixhawk_csys_fixed_rotmat_array)     
        
        pos_pixhawk_LOC = pixhawk_rotmat_F * coord_pixhawk_GLOB.pos # Local position of the pixhawk
        vel_pixhawk_LOC = pixhawk_rotmat_F * coord_dt_pixhawk_GLOB.pos # Local velocities of the pixhawk
        acc_pixhawk_LOC = pixhawk_rotmat_F * coord_dtdt_pixhawk_GLOB.pos # Local accelerations of the pixhawk 
        Wvel_pixhawk_LOC = pixhawk_rotmat_F * Wvel_pixhawk_GLOB # Local Angular velocity of the pixhawk 
        Wacc_pixhawk_LOC = pixhawk_rotmat_F * Wacc_pixhawk_GLOB # Local Angular acceleration of the pixhawk 
        
        pos_pixhawk_LOC_to_GLOB = pixhawk_rotmat * pos_pixhawk_LOC # Global position of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        pos_pixhawk_LOC_to_GLOB_NED = RR * pos_pixhawk_LOC_to_GLOB # Global position of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        vel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * vel_pixhawk_LOC # Global velocity of pixhawk obtained starting from the Local velocity and premultiplying times the rotation matrix
        vel_pixhawk_LOC_to_GLOB_NED = RR * vel_pixhawk_LOC_to_GLOB # Global velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * Wvel_pixhawk_LOC # Global angular velocity of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB_NED = RR * Wvel_pixhawk_LOC_to_GLOB # Global angular velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
        
        # Compute the position (in global coordinates) of the bodies
        # my_box_ref = my_box.GetFrame_REF_to_abs().GetCoord().pos # this gives the position of the auxillary csys imported from/defined in SolidWorks
        my_box_pos = my_box.GetFrame_COG_to_abs().GetCoord().pos # = same as asking for .GetPos() --> meaning GetPos() refers to the COG position!!!!
        my_prop1_pos = my_prop1.GetPos()
        my_prop2_pos = my_prop2.GetPos()
        my_prop3_pos = my_prop3.GetPos()
        my_prop4_pos = my_prop4.GetPos()
        my_prop5_pos = my_prop5.GetPos()
        my_prop6_pos = my_prop6.GetPos()
        my_prop7_pos = my_prop7.GetPos()
        my_prop8_pos = my_prop8.GetPos()
        
        # Compute the COG in Global Coordinates
        # (First you must put the ChVector (position) and then you can multiply it by a float (mass). Order is important!!!)
        COG_total = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
                    (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass) + 
                    my_ball1_pos * my_ball1_mass + my_ball2_pos * my_ball2_mass)*(1/mass_total_wballs)
        
        COG = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
              (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass)) *(1/mass_total)
        
        my_COG_local = my_frame_csys.TransformParentToLocal(COG) # Position of COG seen from the local reference system of the frame
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # # Ball position seen from Box refrence system
        # my_ball1_pos_box = my_box_csys.TransformParentToLocal(my_ball1_pos) # Position of Ball1 seen from the local reference system of the Box
        # my_ball2_pos_box = my_box_csys.TransformParentToLocal(my_ball2_pos) # Position of Ball1 seen from the local reference system of the Box
        # COG_total_box = my_box_csys.TransformParentToLocal(COG_total) # Position of COG_total seen from the local reference system of the Box
               
        # ==========================================================================================================================================================================
        # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk ALA METHOD - CORRECT - 
        quat_pixhawk = marker_pixhawk_2.GetAbsCoord().rot
        quat_pixhawk_e0 = quat_pixhawk.e0
        quat_pixhawk_e1 = -quat_pixhawk.e1
        quat_pixhawk_e2 = quat_pixhawk.e2
        quat_pixhawk_e3 = -quat_pixhawk.e3
        quat_pixhawk_new = chrono.ChQuaternionD(quat_pixhawk_e0, quat_pixhawk_e1, quat_pixhawk_e3, quat_pixhawk_e2) #pixhawk quaternion with y and z components flipped
        
        pixhawk_rotmat_2 = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk_new)
        pixhawk_euler = fun.euler321_from_rotmat(pixhawk_rotmat_2)
        pixhawk_euler_deg_trunc = ['%.3f'%(fun.chvector_to_list(fun.rad2deg(pixhawk_euler))[0]), '%.3f'%(fun.chvector_to_list(fun.rad2deg(pixhawk_euler))[1]), '%.3f'%(fun.chvector_to_list(fun.rad2deg(pixhawk_euler))[2])]
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        # Compute user-defined trajectory
        (translational_position_in_I_user,
         translational_velocity_in_I_user,
         translational_acceleration_in_I_user
        ) = user_defined_trajectory.computeUserDefinedTrajectory(time_now)
        (yaw_ref,
         yaw_ref_dot,
         yaw_ref_ddot
        ) = user_defined_trajectory.computeUserDefinedYaw()
          
        roll = pixhawk_euler.x
        pitch = pixhawk_euler.y
        yaw = pixhawk_euler.z
        translational_position_in_I = np.array(fun.chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        translational_velocity_in_I = np.array(fun.chvector_to_list(vel_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        angular_velocity = np.array(fun.chvector_to_list(Wvel_pixhawk_LOC)).reshape(3,1)
        angular_acceleration = np.array(fun.chvector_to_list(Wacc_pixhawk_LOC)).reshape(3,1)

        ode_input.update(
            translational_position_in_I,
            roll,
            pitch,
            yaw,
            translational_velocity_in_I,
            angular_velocity,
            translational_position_in_I_user,
            translational_velocity_in_I_user,
            translational_acceleration_in_I_user,
            yaw_ref,
            yaw_ref_dot,
            yaw_ref_ddot
        )
        
        
        ################## 
        # Applying AERODYNAMIC FORCE to the drone
        aerodynamic_velocity = np.array(fun.chvector_to_list(vel_pixhawk_LOC)).reshape(3,1)
        aerodynamic_force = (-0.5 * flight_params.air_density_estimated * 
                             flight_params.surface_area_estimated * 
                             flight_params.drag_coefficient_matrix_estimated * 
                             aerodynamic_velocity * LA.norm(aerodynamic_velocity))
        my_frame.Accumulate_force(chrono.ChVectorD(aerodynamic_force[0].item(),aerodynamic_force[1].item(),aerodynamic_force[2].item()),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),True)
        
        # Applying a constant WIND FORCE to the drone, expressed in pychrono global coordinate
        # my_frame.Accumulate_force(chrono.ChVectorD(1,0,0),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),False)
        
        ##################
        if Wrapper_execution == True:
            with open(csv_file_path, mode='w', newline='') as csv_file_wrapper:
                csv_writer = csv.writer(csv_file_wrapper)
                date = datetime.datetime.now(pytz.timezone('America/New_York'))
                introductory_fields = [["Execution Date:", str(date.month) +"-" + str(date.day) +"-" + str(date.year) ,"", "Simulation start time [s]:", str(date.hour)+":"+ str(date.minute)+":"+ str(date.second)], 
                                       ["Controller type:", controller_type ,"","Trajectory:", trajectory_type],
                                       ["Wrapper parameter:", "Ball density:", my_ball_density]]
                csv_writer.writerows(introductory_fields)
                if controller_type == "PID":
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                         "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                         "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]", "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                         "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                         "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                         "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                         "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                        "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]"]
                
                else:   
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                  "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                  "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]",
                                  "x_ref_tran1[m]", "x_ref_tran2[m]", "x_ref_tran3[m]", "x_ref_tran4[m]", "x_ref_tran5[m]", "x_ref_tran6[m]",
                                  "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                  "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                  "omega_ref_x[rad/s]", "omega_ref_y[rad/s]", "omega_ref_z[rad/s]", "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                  "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                  "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                  "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]",
                                  "mu_baseline_tran_x[N]", "mu_baseline_tran_y[N]", "mu_baseline_tran_z[N]", 
                                  "mu_adaptive_tran_x[N]", "mu_adaptive_tran_y[N]", "mu_adaptive_tran_z[N]","mu_PD_baseline_tran_x[N]", "mu_PD_baseline_tran_y[N]", "mu_PD_baseline_tran_z[N]",
                                  "Moment_baseline_x[Nm]", "Moment_baseline_y[Nm]", "Moment_baseline_z[Nm]","Moment_adaptive_x[Nm]", "Moment_adaptive_y[Nm]", "Moment_adaptive_z[Nm]",
                                  "Moment_baseline_PI_x[Nm]", "Moment_baseline_PI_y[Nm]", "Moment_baseline_PI_z[Nm]",
                                  "omega_ref_dot_x[rad/s^2]", "omega_ref_dot_y[rad/s^2]", "omega_ref_dot_z[rad/s^2]",
                                  "omega_cmd_dot_x[rad/s^2]", "omega_cmd_dot_y[rad/s^2]", "omega_cmd_dot_z[rad/s^2]",
                                  "omega_cmd_x[rad/s]", "omega_cmd_y[rad/s]", "omega_cmd_z[rad/s]",
                                  "angular_position_dot_x[rad/s]", "angular_position_dot_y[rad/s]", "angular_position_dot_z[rad/s]"]
             
                len_header = len(header_csv) +1
                column_serial_number =[]
                for i in range(1,len_header):
                    column_serial_number.append(i)
                csv_writer.writerow(column_serial_number)
                csv_writer.writerow(header_csv)
            
        #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  
        if (time_now > flight_params.controller_start_time):   

            # Computing the control algorithm
            controller.computeControlAlgorithm(yin, ode_input)

            # Integrating the ODEs through RK4 for PID controller
            yout = fun.rk4singlestepWP(controller.ode,m_timestep, time_now, yin, ode_input)
            Y_list = np.append(Y_list,np.resize(yout,(gains.number_of_states,1)), axis=1)
            yin = yout

            # Collect the log data
            logger.collect_data(controller, time_now, simulation_time)
            
            # ----------------------------------------------------------------------------------------------------------------------------------------------------------------
                        
            # Thrust saturation
            for i in range(len(controller.motor_thrusts)):
                if controller.motor_thrusts[i][0] < flight_params.minimum_motor_thrust:
                    controller.motor_thrusts[i][0] = flight_params.minimum_motor_thrust # if some component of the thrust force is smaller than the min thrust that can physically be generated set it to T_MIN
                if controller.motor_thrusts[i][0] > flight_params.maximum_motor_thrust:
                    controller.motor_thrusts[i][0] = flight_params.maximum_motor_thrust # if some component of the thrust force is greater than the max thrust that can physically be generated set it to T_MAX
    
            # Accounting for motor efficiency
            controller.motor_thrusts = np.array(flight_params.motor_efficiency_matrix * controller.motor_thrusts)   
            
            # Force applied with the command Accumulate_force()
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[0][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[1][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[2][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[3][0],0),force_4_8_pos,True)
            
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[4][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[5][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[6][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[7][0],0),force_4_8_pos,True)
            
            ### Motor thrust application position flipped wrt y and x axis (local NED convention)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[2][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[3][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[0][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[1][0],0),force_4_8_pos,True)
            
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[6][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[7][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[4][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,controller.motor_thrusts[5][0],0),force_4_8_pos,True)
            ###
            
            # Computation of the angular velocities of the propellers
            # omega = np.sqrt((controller.motor_thrusts/2)/K_omega) # I use half controller.motor_thrusts because the thrust computed is not for a single motor but for a couple
            omega = np.sqrt(controller.motor_thrusts/flight_params.K_omega) # I use controller.motor_thrusts because the thrust computed is for a single motor but not for a couple
            omega_8 = [omega[0], -omega[1], omega[2], -omega[3], -omega[4], omega[5], -omega[6], omega[7]]
        
            torque_1 = chrono.ChVectorD(0,(omega_8[0][0]**2 * flight_params.K_torque),0) 
            torque_2 = chrono.ChVectorD(0,-(omega_8[1][0]**2 * flight_params.K_torque),0)
            torque_3 = chrono.ChVectorD(0,(omega_8[2][0]**2 * flight_params.K_torque),0)
            torque_4 = chrono.ChVectorD(0,-(omega_8[3][0]**2 * flight_params.K_torque),0)
            torque_5 = chrono.ChVectorD(0,-(omega_8[4][0]**2 * flight_params.K_torque),0)
            torque_6 = chrono.ChVectorD(0,(omega_8[5][0]**2 * flight_params.K_torque),0)
            torque_7 = chrono.ChVectorD(0,-(omega_8[6][0]**2 * flight_params.K_torque),0)
            torque_8 = chrono.ChVectorD(0,(omega_8[7][0]**2 * flight_params.K_torque),0)  
    
            torque_total = torque_1.y + torque_2.y + torque_3.y + torque_4.y + torque_5.y + torque_6.y + torque_7.y + torque_8.y
            
            # Torque applied with the command Accumulate_torque()
            my_frame.Accumulate_torque(torque_1, True)
            my_frame.Accumulate_torque(torque_2, True)
            my_frame.Accumulate_torque(torque_3, True)
            my_frame.Accumulate_torque(torque_4, True)
            my_frame.Accumulate_torque(torque_5, True)
            my_frame.Accumulate_torque(torque_6, True)
            my_frame.Accumulate_torque(torque_7, True)
            my_frame.Accumulate_torque(torque_8, True)
            
            # # Torque applied with the command Accumulate_torque() ALL SET TO ZERO
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
        
            ##############################################################################################################
    
            # Motors' rotation direction
            # Motor 1: CCW
            # Motor 2: CW
            # Motor 3: CCW
            # Motor 4: CW
            # Motor 5: CW
            # Motor 6: CCW       
            # Motor 7: CW
            # Motor 8: CCW
            
            # If the controller parameters go beyond 10^6, break the simulation
            if Wrapper_execution == True:
                if abs(u1)>(10**6) or abs(u2)>(10**6) or abs(u3)>(10**6) or abs(u4)>(10**6):
                    with open(csv_file_path_abnormalities, mode='a', newline='') as csv_file_wrapper_ab:
                        csv_writer = csv.writer(csv_file_wrapper_ab)
                        #csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
                        csv_writer.writerow([my_ball_density])  
                    break
            
            # Setting the propeller rotational velocities (all angular velocities are divided by 10)
            link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_8[0][0]/10))
            link_motor2.SetMotorFunction(chrono.ChFunction_Const(omega_8[1][0]/10))
            link_motor3.SetMotorFunction(chrono.ChFunction_Const(omega_8[2][0]/10))
            link_motor4.SetMotorFunction(chrono.ChFunction_Const(omega_8[3][0]/10))
            link_motor5.SetMotorFunction(chrono.ChFunction_Const(omega_8[4][0]/10))
            link_motor6.SetMotorFunction(chrono.ChFunction_Const(omega_8[5][0]/10))
            link_motor7.SetMotorFunction(chrono.ChFunction_Const(omega_8[6][0]/10))
            link_motor8.SetMotorFunction(chrono.ChFunction_Const(omega_8[7][0]/10))
            
            # link_motor1.SetSpeedFunction(chrono.ChFunction_Const(omega_8[0]))
            # omega_fun.Set_yconst(omega_8[0])
            # link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_fun))
        
        # # Payload Dropping
        # time_payloadDropping = 4 # 7AIAA, 11 
        # if (time_now > time_payloadDropping): # 5
        #     my_ball1.SetCollide(False)
        #     my_ball2.SetCollide(False)
            
        # if (time_now > (time_payloadDropping + 0.15)): # 5.15
        #     my_ball1.SetCollide(True)
        #     my_ball2.SetCollide(True)
            
        # Motor Failure#!!!
        # if (time_now > 2.5): # 4AIAA
        #     motor_efficiency_matrix = np.matrix(np.diag([1, 1, 0, 1, 1, 1, 0.3, 1]))
            
        # if (time_now > 1):
        #     maximumRollAngle = math.radians(25) # [rad] 25 - 32
        #     maximumPitchAngle = math.radians(25) # [rad] 25 - 32
    
    
    #========================================================================================================================================
    # # Dropping multiple balls one after the other
    #     collision_states = [True] * 10
    
    #     for i in range(0,10):
    #         variable_name = f'my_ball3_{i}'  # Get the variable name of the current ball
    #         if i>0:
    #             variable_name_previous = f'my_ball3_{i-1}'  # Get the variable name of the current ball
        
    #         if variable_name in globals():
    #             current_ball = globals()[variable_name]
    #         if i>0:
    #             if variable_name_previous in globals():
    #                 previous_ball = globals()[variable_name_previous]
        
    #         # Toggle collision state if the time condition is met
    #         if time_now > 5.0 + i * 0.05:
    #             collision_states[i] = False
    #             # if i>0:
    #             #     collision_states[i-1] = True
            
    #         # Set the collision state based on the flag
    #         current_ball.SetCollide(collision_states[i])
    #         if i>0:
    #             previous_ball.SetCollide(collision_states[i-1])
    #========================================================================================================================================        
        
        # Print data to Console -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        print ('\nSimulation time: ', time_now)
        print('Time the simulation is taking: ', '%.4f'%simulation_time)
        
        print_cosole_flag = False
        if (print_cosole_flag):
    
          print('angular_error: ', '%.4f'%angular_error[0], '%.4f'%angular_error[1], '%.4f'%angular_error[2])
          print('angular_error_dot: ', '%.4f'%angular_error_dot[0], '%.4f'%angular_error_dot[1], '%.4f'%angular_error_dot[2])
          print('Thrust T: ', '%.4f'%controller.motor_thrusts[0], '%.4f'%controller.motor_thrusts[1], '%.4f'%controller.motor_thrusts[2], '%.4f'%controller.motor_thrusts[3], '%.4f'%controller.motor_thrusts[4], '%.4f'%controller.motor_thrusts[5], '%.4f'%controller.motor_thrusts[6], '%.4f'%controller.motor_thrusts[7])
          print('Total thrust: ', '%4f'%np.sum(controller.motor_thrusts))
          print('Total torque around Z_onboard: ', '%.4f'%torque_total)          
          print('Pixhawk Euler 321 angles [deg]: ', pixhawk_euler_deg_trunc)       
          print('Controllers U1 U2 U3 U4: ', '%.4f'%U[0], '%.4f'%U[1], '%.4f'%U[2], '%.4f'%U[3])
          print('mu: ', '%.4f'%mu_x, '%.4f'%mu_y, '%.4f'%mu_z)          
          print ('Roll reference [deg]: ', '%.4f'%np.fun.rad2deg(roll_ref))
          print ('Pitch reference [deg]: ', '%.4f'%np.fun.rad2deg(pitch_ref))
          print ('Yaw reference [deg]: ', '%.4f'%np.fun.rad2deg(yaw_ref))
          print ('mu_PD_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_PD_baseline_tran), '%.4f'%mu_PD_baseline_tran[0].item(), '%.4f'%mu_PD_baseline_tran[1].item(), '%.4f'%mu_PD_baseline_tran[2].item())
          print ('mu_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_baseline_tran), '%.4f'%mu_baseline_tran[0].item(), '%.4f'%mu_baseline_tran[1].item(), '%.4f'%mu_baseline_tran[2].item())
          print ('mu_adaptive_tran [norm x y z]: ', '%.4f'%LA.norm(mu_adaptive_tran), '%.4f'%mu_adaptive_tran[0].item(), '%.4f'%mu_adaptive_tran[1].item(), '%.4f'%mu_adaptive_tran[2].item())
          print ('Moment_baseline_PI [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline_PI), '%.4f'%Moment_baseline_PI[0].item(), '%.4f'%Moment_baseline_PI[1].item(), '%.4f'%Moment_baseline_PI[2].item())
          print ('Moment_baseline [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline), '%.4f'%Moment_baseline[0].item(), '%.4f'%Moment_baseline[1].item(), '%.4f'%Moment_baseline[2].item())
          print ('Moment_adaptive [norm x y z]: ', '%.4f'%LA.norm(Moment_adaptive), '%.4f'%Moment_adaptive[0].item(), '%.4f'%Moment_adaptive[1].item(), '%.4f'%Moment_adaptive[2].item())                  
          print('Pixhawk GLOBAL Position: ', '%.4f'%fun.chvector_to_list(coord_pixhawk_GLOB)[0][0],
                                             '%.4f'%fun.chvector_to_list(coord_pixhawk_GLOB)[0][1],
                                             '%.4f'%fun.chvector_to_list(coord_pixhawk_GLOB)[0][2])
          print('Pixhawk GLOBAL Velocity NORM: ', '%.4f'%LA.norm(np.asarray(fun.chvector_to_list(coord_dt_pixhawk_GLOB)[0])))
          
    if Wrapper_execution == True:
        DATA = DATA.T
        with open(csv_file_path, mode='a', newline='') as csv_file_wrapper:
            csv_writer = csv.writer(csv_file_wrapper)
            #csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
            csv_writer.writerows(DATA)                   

    ########### Export log data ###########
            
    elif Wrapper_execution == False:

        log_dict = logger.to_dictionary()

        # Export data to MATLAB workspace
        Logging.saveMatlabWorkspaceLog(log_dict, gains, controller_type)